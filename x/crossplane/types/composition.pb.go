// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: overlock/crossplane/composition.proto

package types

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Composition represents the composition of resources.
type Composition struct {
	Id       uint64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Metadata *Metadata        `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Spec     *CompositionSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Composition) Reset()         { *m = Composition{} }
func (m *Composition) String() string { return proto.CompactTextString(m) }
func (*Composition) ProtoMessage()    {}
func (*Composition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{0}
}
func (m *Composition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Composition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Composition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Composition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Composition.Merge(m, src)
}
func (m *Composition) XXX_Size() int {
	return m.Size()
}
func (m *Composition) XXX_DiscardUnknown() {
	xxx_messageInfo_Composition.DiscardUnknown(m)
}

var xxx_messageInfo_Composition proto.InternalMessageInfo

func (m *Composition) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Composition) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Composition) GetSpec() *CompositionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Spec defines the specification of the composition.
type CompositionSpec struct {
	CompositeTypeRef *CompositeTypeRef `protobuf:"bytes,3,opt,name=composite_type_ref,json=compositeTypeRef,proto3" json:"composite_type_ref,omitempty"`
	Mode             string            `protobuf:"bytes,4,opt,name=mode,proto3" json:"mode,omitempty"`
	Resources        []*Resource       `protobuf:"bytes,6,rep,name=resources,proto3" json:"resources,omitempty"`
}

func (m *CompositionSpec) Reset()         { *m = CompositionSpec{} }
func (m *CompositionSpec) String() string { return proto.CompactTextString(m) }
func (*CompositionSpec) ProtoMessage()    {}
func (*CompositionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{1}
}
func (m *CompositionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompositionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompositionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositionSpec.Merge(m, src)
}
func (m *CompositionSpec) XXX_Size() int {
	return m.Size()
}
func (m *CompositionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CompositionSpec proto.InternalMessageInfo

func (m *CompositionSpec) GetCompositeTypeRef() *CompositeTypeRef {
	if m != nil {
		return m.CompositeTypeRef
	}
	return nil
}

func (m *CompositionSpec) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *CompositionSpec) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// CompositeTypeRef references a composite type.
type CompositeTypeRef struct {
	ApiVersion string `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	Kind       string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *CompositeTypeRef) Reset()         { *m = CompositeTypeRef{} }
func (m *CompositeTypeRef) String() string { return proto.CompactTextString(m) }
func (*CompositeTypeRef) ProtoMessage()    {}
func (*CompositeTypeRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{2}
}
func (m *CompositeTypeRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeTypeRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompositeTypeRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompositeTypeRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeTypeRef.Merge(m, src)
}
func (m *CompositeTypeRef) XXX_Size() int {
	return m.Size()
}
func (m *CompositeTypeRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeTypeRef.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeTypeRef proto.InternalMessageInfo

func (m *CompositeTypeRef) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *CompositeTypeRef) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

// Resource represents a resource in the composition.
type Resource struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Base    *Base    `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty"`
	Patches []*Patch `protobuf:"bytes,3,rep,name=patches,proto3" json:"patches,omitempty"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{3}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.Size()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Resource) GetBase() *Base {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *Resource) GetPatches() []*Patch {
	if m != nil {
		return m.Patches
	}
	return nil
}

// Base defines the base resource.
type Base struct {
	ApiVersion string `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	Kind       string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *Base) Reset()         { *m = Base{} }
func (m *Base) String() string { return proto.CompactTextString(m) }
func (*Base) ProtoMessage()    {}
func (*Base) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{4}
}
func (m *Base) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Base) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Base.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Base) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Base.Merge(m, src)
}
func (m *Base) XXX_Size() int {
	return m.Size()
}
func (m *Base) XXX_DiscardUnknown() {
	xxx_messageInfo_Base.DiscardUnknown(m)
}

var xxx_messageInfo_Base proto.InternalMessageInfo

func (m *Base) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *Base) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

// Patch represents a patch to be applied to a resource.
type Patch struct {
	Type          string         `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	FromFieldPath string         `protobuf:"bytes,2,opt,name=from_field_path,json=fromFieldPath,proto3" json:"from_field_path,omitempty"`
	ToFieldPath   string         `protobuf:"bytes,3,opt,name=to_field_path,json=toFieldPath,proto3" json:"to_field_path,omitempty"`
	Transforms    []*Transformer `protobuf:"bytes,5,rep,name=transforms,proto3" json:"transforms,omitempty"`
}

func (m *Patch) Reset()         { *m = Patch{} }
func (m *Patch) String() string { return proto.CompactTextString(m) }
func (*Patch) ProtoMessage()    {}
func (*Patch) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{5}
}
func (m *Patch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Patch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Patch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Patch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Patch.Merge(m, src)
}
func (m *Patch) XXX_Size() int {
	return m.Size()
}
func (m *Patch) XXX_DiscardUnknown() {
	xxx_messageInfo_Patch.DiscardUnknown(m)
}

var xxx_messageInfo_Patch proto.InternalMessageInfo

func (m *Patch) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Patch) GetFromFieldPath() string {
	if m != nil {
		return m.FromFieldPath
	}
	return ""
}

func (m *Patch) GetToFieldPath() string {
	if m != nil {
		return m.ToFieldPath
	}
	return ""
}

func (m *Patch) GetTransforms() []*Transformer {
	if m != nil {
		return m.Transforms
	}
	return nil
}

// Transformer represents a transformation to be applied.
type Transformer struct {
	// transform defines the type of transformation to be applied.
	//
	// Types that are valid to be assigned to Transform:
	//
	//	*Transformer_Map
	//	*Transformer_String_
	//	*Transformer_Math
	//	*Transformer_Match
	//	*Transformer_Convert
	Transform isTransformer_Transform `protobuf_oneof:"transform"`
}

func (m *Transformer) Reset()         { *m = Transformer{} }
func (m *Transformer) String() string { return proto.CompactTextString(m) }
func (*Transformer) ProtoMessage()    {}
func (*Transformer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{6}
}
func (m *Transformer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transformer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transformer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transformer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transformer.Merge(m, src)
}
func (m *Transformer) XXX_Size() int {
	return m.Size()
}
func (m *Transformer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transformer.DiscardUnknown(m)
}

var xxx_messageInfo_Transformer proto.InternalMessageInfo

type isTransformer_Transform interface {
	isTransformer_Transform()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Transformer_Map struct {
	Map string `protobuf:"bytes,1,opt,name=map,proto3,oneof" json:"map,omitempty"`
}
type Transformer_String_ struct {
	String_ *StringTransform `protobuf:"bytes,2,opt,name=string,proto3,oneof" json:"string,omitempty"`
}
type Transformer_Math struct {
	Math *MathTransform `protobuf:"bytes,3,opt,name=math,proto3,oneof" json:"math,omitempty"`
}
type Transformer_Match struct {
	Match *MatchTransform `protobuf:"bytes,4,opt,name=match,proto3,oneof" json:"match,omitempty"`
}
type Transformer_Convert struct {
	Convert *ConvertTransform `protobuf:"bytes,5,opt,name=convert,proto3,oneof" json:"convert,omitempty"`
}

func (*Transformer_Map) isTransformer_Transform()     {}
func (*Transformer_String_) isTransformer_Transform() {}
func (*Transformer_Math) isTransformer_Transform()    {}
func (*Transformer_Match) isTransformer_Transform()   {}
func (*Transformer_Convert) isTransformer_Transform() {}

func (m *Transformer) GetTransform() isTransformer_Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *Transformer) GetMap() string {
	if x, ok := m.GetTransform().(*Transformer_Map); ok {
		return x.Map
	}
	return ""
}

func (m *Transformer) GetString_() *StringTransform {
	if x, ok := m.GetTransform().(*Transformer_String_); ok {
		return x.String_
	}
	return nil
}

func (m *Transformer) GetMath() *MathTransform {
	if x, ok := m.GetTransform().(*Transformer_Math); ok {
		return x.Math
	}
	return nil
}

func (m *Transformer) GetMatch() *MatchTransform {
	if x, ok := m.GetTransform().(*Transformer_Match); ok {
		return x.Match
	}
	return nil
}

func (m *Transformer) GetConvert() *ConvertTransform {
	if x, ok := m.GetTransform().(*Transformer_Convert); ok {
		return x.Convert
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Transformer) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Transformer_Map)(nil),
		(*Transformer_String_)(nil),
		(*Transformer_Math)(nil),
		(*Transformer_Match)(nil),
		(*Transformer_Convert)(nil),
	}
}

// StringTransform defines a string transformation.
type StringTransform struct {
	// type defines the type of string transformation.
	//
	// Types that are valid to be assigned to TransformType:
	//
	//	*StringTransform_Convert
	//	*StringTransform_Format
	TransformType isStringTransform_TransformType `protobuf_oneof:"transform_type"`
}

func (m *StringTransform) Reset()         { *m = StringTransform{} }
func (m *StringTransform) String() string { return proto.CompactTextString(m) }
func (*StringTransform) ProtoMessage()    {}
func (*StringTransform) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{7}
}
func (m *StringTransform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringTransform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringTransform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringTransform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringTransform.Merge(m, src)
}
func (m *StringTransform) XXX_Size() int {
	return m.Size()
}
func (m *StringTransform) XXX_DiscardUnknown() {
	xxx_messageInfo_StringTransform.DiscardUnknown(m)
}

var xxx_messageInfo_StringTransform proto.InternalMessageInfo

type isStringTransform_TransformType interface {
	isStringTransform_TransformType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StringTransform_Convert struct {
	Convert *StringConvert `protobuf:"bytes,1,opt,name=convert,proto3,oneof" json:"convert,omitempty"`
}
type StringTransform_Format struct {
	Format *StringFormat `protobuf:"bytes,2,opt,name=format,proto3,oneof" json:"format,omitempty"`
}

func (*StringTransform_Convert) isStringTransform_TransformType() {}
func (*StringTransform_Format) isStringTransform_TransformType()  {}

func (m *StringTransform) GetTransformType() isStringTransform_TransformType {
	if m != nil {
		return m.TransformType
	}
	return nil
}

func (m *StringTransform) GetConvert() *StringConvert {
	if x, ok := m.GetTransformType().(*StringTransform_Convert); ok {
		return x.Convert
	}
	return nil
}

func (m *StringTransform) GetFormat() *StringFormat {
	if x, ok := m.GetTransformType().(*StringTransform_Format); ok {
		return x.Format
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StringTransform) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StringTransform_Convert)(nil),
		(*StringTransform_Format)(nil),
	}
}

// StringConvert defines a string conversion.
type StringConvert struct {
	Convert string `protobuf:"bytes,1,opt,name=convert,proto3" json:"convert,omitempty"`
}

func (m *StringConvert) Reset()         { *m = StringConvert{} }
func (m *StringConvert) String() string { return proto.CompactTextString(m) }
func (*StringConvert) ProtoMessage()    {}
func (*StringConvert) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{8}
}
func (m *StringConvert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringConvert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringConvert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringConvert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringConvert.Merge(m, src)
}
func (m *StringConvert) XXX_Size() int {
	return m.Size()
}
func (m *StringConvert) XXX_DiscardUnknown() {
	xxx_messageInfo_StringConvert.DiscardUnknown(m)
}

var xxx_messageInfo_StringConvert proto.InternalMessageInfo

func (m *StringConvert) GetConvert() string {
	if m != nil {
		return m.Convert
	}
	return ""
}

// StringFormat defines a string format.
type StringFormat struct {
	Fmt string `protobuf:"bytes,1,opt,name=fmt,proto3" json:"fmt,omitempty"`
}

func (m *StringFormat) Reset()         { *m = StringFormat{} }
func (m *StringFormat) String() string { return proto.CompactTextString(m) }
func (*StringFormat) ProtoMessage()    {}
func (*StringFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{9}
}
func (m *StringFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringFormat.Merge(m, src)
}
func (m *StringFormat) XXX_Size() int {
	return m.Size()
}
func (m *StringFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_StringFormat.DiscardUnknown(m)
}

var xxx_messageInfo_StringFormat proto.InternalMessageInfo

func (m *StringFormat) GetFmt() string {
	if m != nil {
		return m.Fmt
	}
	return ""
}

// MathTransform defines a mathematical transformation.
type MathTransform struct {
	// operation defines the mathematical operation to be applied.
	//
	// Types that are valid to be assigned to Operation:
	//
	//	*MathTransform_ClampMin
	//	*MathTransform_ClampMax
	//	*MathTransform_Multiply
	Operation isMathTransform_Operation `protobuf_oneof:"operation"`
}

func (m *MathTransform) Reset()         { *m = MathTransform{} }
func (m *MathTransform) String() string { return proto.CompactTextString(m) }
func (*MathTransform) ProtoMessage()    {}
func (*MathTransform) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{10}
}
func (m *MathTransform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MathTransform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MathTransform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MathTransform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MathTransform.Merge(m, src)
}
func (m *MathTransform) XXX_Size() int {
	return m.Size()
}
func (m *MathTransform) XXX_DiscardUnknown() {
	xxx_messageInfo_MathTransform.DiscardUnknown(m)
}

var xxx_messageInfo_MathTransform proto.InternalMessageInfo

type isMathTransform_Operation interface {
	isMathTransform_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MathTransform_ClampMin struct {
	ClampMin float64 `protobuf:"fixed64,1,opt,name=clamp_min,json=clampMin,proto3,oneof" json:"clamp_min,omitempty"`
}
type MathTransform_ClampMax struct {
	ClampMax float64 `protobuf:"fixed64,2,opt,name=clamp_max,json=clampMax,proto3,oneof" json:"clamp_max,omitempty"`
}
type MathTransform_Multiply struct {
	Multiply float64 `protobuf:"fixed64,3,opt,name=multiply,proto3,oneof" json:"multiply,omitempty"`
}

func (*MathTransform_ClampMin) isMathTransform_Operation() {}
func (*MathTransform_ClampMax) isMathTransform_Operation() {}
func (*MathTransform_Multiply) isMathTransform_Operation() {}

func (m *MathTransform) GetOperation() isMathTransform_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *MathTransform) GetClampMin() float64 {
	if x, ok := m.GetOperation().(*MathTransform_ClampMin); ok {
		return x.ClampMin
	}
	return 0
}

func (m *MathTransform) GetClampMax() float64 {
	if x, ok := m.GetOperation().(*MathTransform_ClampMax); ok {
		return x.ClampMax
	}
	return 0
}

func (m *MathTransform) GetMultiply() float64 {
	if x, ok := m.GetOperation().(*MathTransform_Multiply); ok {
		return x.Multiply
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MathTransform) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MathTransform_ClampMin)(nil),
		(*MathTransform_ClampMax)(nil),
		(*MathTransform_Multiply)(nil),
	}
}

// MatchTransform defines a match transformation.
type MatchTransform struct {
	Patterns      []*Pattern `protobuf:"bytes,1,rep,name=patterns,proto3" json:"patterns,omitempty"`
	FallbackTo    string     `protobuf:"bytes,2,opt,name=fallback_to,json=fallbackTo,proto3" json:"fallback_to,omitempty"`
	FallbackValue string     `protobuf:"bytes,3,opt,name=fallback_value,json=fallbackValue,proto3" json:"fallback_value,omitempty"`
}

func (m *MatchTransform) Reset()         { *m = MatchTransform{} }
func (m *MatchTransform) String() string { return proto.CompactTextString(m) }
func (*MatchTransform) ProtoMessage()    {}
func (*MatchTransform) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{11}
}
func (m *MatchTransform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchTransform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchTransform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchTransform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchTransform.Merge(m, src)
}
func (m *MatchTransform) XXX_Size() int {
	return m.Size()
}
func (m *MatchTransform) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchTransform.DiscardUnknown(m)
}

var xxx_messageInfo_MatchTransform proto.InternalMessageInfo

func (m *MatchTransform) GetPatterns() []*Pattern {
	if m != nil {
		return m.Patterns
	}
	return nil
}

func (m *MatchTransform) GetFallbackTo() string {
	if m != nil {
		return m.FallbackTo
	}
	return ""
}

func (m *MatchTransform) GetFallbackValue() string {
	if m != nil {
		return m.FallbackValue
	}
	return ""
}

// Pattern represents a pattern in the match transformation.
type Pattern struct {
	Type   string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Result string `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *Pattern) Reset()         { *m = Pattern{} }
func (m *Pattern) String() string { return proto.CompactTextString(m) }
func (*Pattern) ProtoMessage()    {}
func (*Pattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{12}
}
func (m *Pattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pattern.Merge(m, src)
}
func (m *Pattern) XXX_Size() int {
	return m.Size()
}
func (m *Pattern) XXX_DiscardUnknown() {
	xxx_messageInfo_Pattern.DiscardUnknown(m)
}

var xxx_messageInfo_Pattern proto.InternalMessageInfo

func (m *Pattern) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Pattern) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

// ConvertTransform defines a conversion transformation.
type ConvertTransform struct {
	ToType string `protobuf:"bytes,1,opt,name=to_type,json=toType,proto3" json:"to_type,omitempty"`
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
}

func (m *ConvertTransform) Reset()         { *m = ConvertTransform{} }
func (m *ConvertTransform) String() string { return proto.CompactTextString(m) }
func (*ConvertTransform) ProtoMessage()    {}
func (*ConvertTransform) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c5c8dbbbb777bca, []int{13}
}
func (m *ConvertTransform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertTransform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertTransform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertTransform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertTransform.Merge(m, src)
}
func (m *ConvertTransform) XXX_Size() int {
	return m.Size()
}
func (m *ConvertTransform) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertTransform.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertTransform proto.InternalMessageInfo

func (m *ConvertTransform) GetToType() string {
	if m != nil {
		return m.ToType
	}
	return ""
}

func (m *ConvertTransform) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func init() {
	proto.RegisterType((*Composition)(nil), "overlock.crossplane.Composition")
	proto.RegisterType((*CompositionSpec)(nil), "overlock.crossplane.CompositionSpec")
	proto.RegisterType((*CompositeTypeRef)(nil), "overlock.crossplane.CompositeTypeRef")
	proto.RegisterType((*Resource)(nil), "overlock.crossplane.Resource")
	proto.RegisterType((*Base)(nil), "overlock.crossplane.Base")
	proto.RegisterType((*Patch)(nil), "overlock.crossplane.Patch")
	proto.RegisterType((*Transformer)(nil), "overlock.crossplane.Transformer")
	proto.RegisterType((*StringTransform)(nil), "overlock.crossplane.StringTransform")
	proto.RegisterType((*StringConvert)(nil), "overlock.crossplane.StringConvert")
	proto.RegisterType((*StringFormat)(nil), "overlock.crossplane.StringFormat")
	proto.RegisterType((*MathTransform)(nil), "overlock.crossplane.MathTransform")
	proto.RegisterType((*MatchTransform)(nil), "overlock.crossplane.MatchTransform")
	proto.RegisterType((*Pattern)(nil), "overlock.crossplane.Pattern")
	proto.RegisterType((*ConvertTransform)(nil), "overlock.crossplane.ConvertTransform")
}

func init() {
	proto.RegisterFile("overlock/crossplane/composition.proto", fileDescriptor_1c5c8dbbbb777bca)
}

var fileDescriptor_1c5c8dbbbb777bca = []byte{
	// 794 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0xf3, 0xdf, 0xcf, 0x24, 0x8d, 0x06, 0x09, 0xcc, 0xb2, 0x1b, 0x82, 0xa1, 0xa8, 0x1c,
	0xc8, 0x4a, 0x85, 0x95, 0x16, 0x45, 0x5a, 0x41, 0x57, 0x5a, 0x7a, 0xa9, 0x54, 0x4d, 0xa3, 0x1e,
	0xb8, 0x58, 0x53, 0x67, 0x42, 0xac, 0xda, 0x9e, 0xd1, 0xcc, 0x24, 0x4a, 0xcf, 0x7c, 0x01, 0xc4,
	0x27, 0xe0, 0x08, 0x9f, 0x80, 0xaf, 0xc0, 0xb1, 0x47, 0x8e, 0xa8, 0xfd, 0x22, 0x68, 0x26, 0x63,
	0xc7, 0x89, 0xdc, 0x1c, 0xf6, 0x36, 0x7e, 0xef, 0xf7, 0xfb, 0xbd, 0x3f, 0xf3, 0xde, 0x18, 0x8e,
	0xd9, 0x8a, 0x8a, 0x84, 0x45, 0xb7, 0x2f, 0x23, 0xc1, 0xa4, 0xe4, 0x09, 0xc9, 0xe8, 0xcb, 0x88,
	0xa5, 0x9c, 0xc9, 0x58, 0xc5, 0x2c, 0x1b, 0x73, 0xc1, 0x14, 0x43, 0x1f, 0xe6, 0xb0, 0xf1, 0x16,
	0xf6, 0x2c, 0xa8, 0xe2, 0xa6, 0x54, 0x91, 0x19, 0x51, 0x64, 0x43, 0x0c, 0x7e, 0x77, 0xc0, 0x7b,
	0xbb, 0x95, 0x43, 0x7d, 0xa8, 0xc7, 0x33, 0xdf, 0x19, 0x39, 0x27, 0x4d, 0x5c, 0x8f, 0x67, 0xe8,
	0x7b, 0xe8, 0xe6, 0x0c, 0xbf, 0x3e, 0x72, 0x4e, 0xbc, 0xd3, 0x17, 0xe3, 0x8a, 0x58, 0xe3, 0x0b,
	0x0b, 0xc2, 0x05, 0x1c, 0xbd, 0x86, 0xa6, 0xe4, 0x34, 0xf2, 0x1b, 0x86, 0xf6, 0x65, 0x25, 0xad,
	0x14, 0xfa, 0x8a, 0xd3, 0x08, 0x1b, 0x46, 0xf0, 0xb7, 0x03, 0x47, 0x7b, 0x1e, 0x74, 0x05, 0x28,
	0x2f, 0x9b, 0x86, 0xea, 0x8e, 0xd3, 0x50, 0xd0, 0xb9, 0xd5, 0x3e, 0x3e, 0xa8, 0x4d, 0xa7, 0x77,
	0x9c, 0x62, 0x3a, 0xc7, 0x83, 0x68, 0xcf, 0x82, 0x10, 0x34, 0x53, 0x36, 0xa3, 0x7e, 0x73, 0xe4,
	0x9c, 0xb8, 0xd8, 0x9c, 0xd1, 0x04, 0x5c, 0x41, 0x25, 0x5b, 0x8a, 0x88, 0x4a, 0xbf, 0x3d, 0x6a,
	0x3c, 0x59, 0x32, 0xb6, 0x28, 0xbc, 0xc5, 0x07, 0x3f, 0xc1, 0x60, 0x3f, 0x2c, 0xfa, 0x0c, 0x3c,
	0xc2, 0xe3, 0x70, 0x45, 0x85, 0x8c, 0x59, 0x66, 0x7a, 0xeb, 0x62, 0x20, 0x3c, 0xbe, 0xde, 0x58,
	0x74, 0x16, 0xb7, 0x71, 0x36, 0x33, 0xfd, 0x75, 0xb1, 0x39, 0x07, 0xbf, 0x3a, 0xd0, 0xcd, 0x03,
	0x68, 0x40, 0x46, 0x52, 0x6a, 0xa9, 0xe6, 0x8c, 0xbe, 0x81, 0xe6, 0x0d, 0x91, 0xd4, 0x5e, 0xca,
	0x27, 0x95, 0x19, 0x9e, 0x11, 0x49, 0xb1, 0x81, 0xa1, 0xef, 0xa0, 0xc3, 0x89, 0x8a, 0x16, 0x54,
	0xfa, 0x0d, 0x53, 0xd3, 0xb3, 0x4a, 0xc6, 0xa5, 0xc6, 0xe0, 0x1c, 0x1a, 0x4c, 0xa0, 0xa9, 0x35,
	0xde, 0xaf, 0x84, 0xbf, 0x1c, 0x68, 0x19, 0x3d, 0xed, 0xd5, 0x37, 0x96, 0xe7, 0xaf, 0xcf, 0xe8,
	0x2b, 0x38, 0x9a, 0x0b, 0x96, 0x86, 0xf3, 0x98, 0x26, 0xb3, 0x90, 0x13, 0xb5, 0xb0, 0xe4, 0x9e,
	0x36, 0xbf, 0xd3, 0xd6, 0x4b, 0xa2, 0x16, 0x28, 0x80, 0x9e, 0x62, 0x65, 0x54, 0xc3, 0xa0, 0x3c,
	0xc5, 0xb6, 0x98, 0x1f, 0x00, 0x94, 0x20, 0x99, 0x9c, 0x33, 0x91, 0x4a, 0xbf, 0x65, 0xea, 0x1b,
	0x55, 0xd6, 0x37, 0xcd, 0x61, 0x54, 0xe0, 0x12, 0x27, 0xf8, 0xb3, 0x0e, 0x5e, 0xc9, 0x87, 0x10,
	0x34, 0x52, 0xc2, 0x37, 0x09, 0x9f, 0xd7, 0xb0, 0xfe, 0x40, 0x6f, 0xa0, 0x2d, 0x95, 0x88, 0xb3,
	0x5f, 0x6c, 0xcf, 0xab, 0x27, 0xfa, 0xca, 0x40, 0x0a, 0xad, 0xf3, 0x1a, 0xb6, 0x2c, 0xbd, 0x0f,
	0x69, 0x5e, 0x80, 0x77, 0x1a, 0x54, 0xaf, 0x11, 0x51, 0x8b, 0x32, 0xd7, 0x30, 0xd0, 0x04, 0x5a,
	0xa9, 0x6e, 0xa4, 0x99, 0x53, 0xef, 0xf4, 0x8b, 0xa7, 0xa8, 0xd1, 0x0e, 0x77, 0xc3, 0x41, 0x3f,
	0x42, 0x27, 0x62, 0xd9, 0x8a, 0x0a, 0xe5, 0xb7, 0x0e, 0x6e, 0x8b, 0xc1, 0x94, 0x05, 0x72, 0xde,
	0x99, 0x07, 0x6e, 0xd1, 0xab, 0xe0, 0x0f, 0x07, 0x8e, 0xf6, 0x8a, 0x44, 0x6f, 0xb6, 0x31, 0x9c,
	0x03, 0xd5, 0x6d, 0x68, 0x36, 0x52, 0x29, 0x00, 0x9a, 0x40, 0x5b, 0xeb, 0x10, 0x65, 0x5b, 0xfb,
	0xf9, 0x01, 0xfa, 0x3b, 0x03, 0xd4, 0x7d, 0xdd, 0x50, 0xce, 0x06, 0xd0, 0x2f, 0xb2, 0x33, 0x2f,
	0x43, 0xf0, 0x35, 0xf4, 0x76, 0x42, 0x21, 0x7f, 0x37, 0x3f, 0xb7, 0x88, 0x1c, 0x8c, 0xe0, 0x83,
	0xb2, 0x2c, 0x1a, 0x40, 0x63, 0x9e, 0xe6, 0x28, 0x7d, 0x0c, 0xd6, 0xd0, 0xdb, 0xb9, 0x15, 0xf4,
	0x02, 0xdc, 0x28, 0x21, 0x29, 0x0f, 0xd3, 0x78, 0xb3, 0x0a, 0xce, 0x79, 0x0d, 0x77, 0x8d, 0xe9,
	0x22, 0xce, 0x4a, 0x6e, 0xb2, 0x36, 0xe5, 0x94, 0xdc, 0x64, 0x8d, 0x9e, 0x43, 0x37, 0x5d, 0x26,
	0x2a, 0xe6, 0xc9, 0x9d, 0x99, 0x04, 0xe3, 0xcd, 0x2d, 0xba, 0xd3, 0x8c, 0x53, 0x41, 0xf4, 0xb3,
	0xa7, 0xdf, 0xe6, 0xfe, 0xee, 0xad, 0xa2, 0xd7, 0xd0, 0xe5, 0x44, 0x29, 0x2a, 0x32, 0xe9, 0x3b,
	0x66, 0xce, 0x9f, 0x3f, 0xb5, 0xc7, 0x1a, 0x84, 0x0b, 0xb4, 0x5e, 0xe1, 0x39, 0x49, 0x92, 0x1b,
	0x12, 0xdd, 0x86, 0x8a, 0xd9, 0x5d, 0x83, 0xdc, 0x34, 0x65, 0xe8, 0x18, 0xfa, 0x05, 0x60, 0x45,
	0x92, 0x25, 0xb5, 0x9b, 0xd6, 0xcb, 0xad, 0xd7, 0xda, 0x18, 0xbc, 0x82, 0x8e, 0x15, 0xaf, 0x5c,
	0xeb, 0x8f, 0xa0, 0x2d, 0xa8, 0x5c, 0x26, 0xca, 0x46, 0xb0, 0x5f, 0xc1, 0x5b, 0xfd, 0x30, 0xee,
	0x4e, 0x18, 0xfa, 0x18, 0x3a, 0x8a, 0x85, 0x25, 0x89, 0xb6, 0x62, 0x53, 0x2b, 0x52, 0x1a, 0x07,
	0xb7, 0xb8, 0xe9, 0x57, 0xff, 0x3c, 0x0c, 0x9d, 0xfb, 0x87, 0xa1, 0xf3, 0xdf, 0xc3, 0xd0, 0xf9,
	0xed, 0x71, 0x58, 0xbb, 0x7f, 0x1c, 0xd6, 0xfe, 0x7d, 0x1c, 0xd6, 0x7e, 0xfe, 0xb4, 0xf8, 0xd5,
	0xad, 0xcb, 0x3f, 0x3b, 0xad, 0x2d, 0x6f, 0xda, 0xe6, 0x57, 0xf7, 0xed, 0xff, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x68, 0x90, 0xf1, 0xe7, 0x4c, 0x07, 0x00, 0x00,
}

func (m *Composition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Composition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Composition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintComposition(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComposition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x22
	}
	if m.CompositeTypeRef != nil {
		{
			size, err := m.CompositeTypeRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CompositeTypeRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeTypeRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeTypeRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApiVersion) > 0 {
		i -= len(m.ApiVersion)
		copy(dAtA[i:], m.ApiVersion)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.ApiVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Patches) > 0 {
		for iNdEx := len(m.Patches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Patches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComposition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Base) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Base) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Base) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApiVersion) > 0 {
		i -= len(m.ApiVersion)
		copy(dAtA[i:], m.ApiVersion)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.ApiVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Patch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Patch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Patch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transforms) > 0 {
		for iNdEx := len(m.Transforms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transforms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComposition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ToFieldPath) > 0 {
		i -= len(m.ToFieldPath)
		copy(dAtA[i:], m.ToFieldPath)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.ToFieldPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FromFieldPath) > 0 {
		i -= len(m.FromFieldPath)
		copy(dAtA[i:], m.FromFieldPath)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.FromFieldPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transformer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transformer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transform != nil {
		{
			size := m.Transform.Size()
			i -= size
			if _, err := m.Transform.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Transformer_Map) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer_Map) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Map)
	copy(dAtA[i:], m.Map)
	i = encodeVarintComposition(dAtA, i, uint64(len(m.Map)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Transformer_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Transformer_Math) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer_Math) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Math != nil {
		{
			size, err := m.Math.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Transformer_Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer_Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Transformer_Convert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transformer_Convert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Convert != nil {
		{
			size, err := m.Convert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StringTransform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringTransform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringTransform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransformType != nil {
		{
			size := m.TransformType.Size()
			i -= size
			if _, err := m.TransformType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringTransform_Convert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringTransform_Convert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Convert != nil {
		{
			size, err := m.Convert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StringTransform_Format) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringTransform_Format) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Format != nil {
		{
			size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComposition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StringConvert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringConvert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringConvert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Convert) > 0 {
		i -= len(m.Convert)
		copy(dAtA[i:], m.Convert)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Convert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fmt) > 0 {
		i -= len(m.Fmt)
		copy(dAtA[i:], m.Fmt)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Fmt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MathTransform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MathTransform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MathTransform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MathTransform_ClampMin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MathTransform_ClampMin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ClampMin))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}
func (m *MathTransform_ClampMax) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MathTransform_ClampMax) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ClampMax))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *MathTransform_Multiply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MathTransform_Multiply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Multiply))))
	i--
	dAtA[i] = 0x19
	return len(dAtA) - i, nil
}
func (m *MatchTransform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchTransform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchTransform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FallbackValue) > 0 {
		i -= len(m.FallbackValue)
		copy(dAtA[i:], m.FallbackValue)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.FallbackValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FallbackTo) > 0 {
		i -= len(m.FallbackTo)
		copy(dAtA[i:], m.FallbackTo)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.FallbackTo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Patterns) > 0 {
		for iNdEx := len(m.Patterns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Patterns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComposition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Pattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertTransform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertTransform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertTransform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToType) > 0 {
		i -= len(m.ToType)
		copy(dAtA[i:], m.ToType)
		i = encodeVarintComposition(dAtA, i, uint64(len(m.ToType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintComposition(dAtA []byte, offset int, v uint64) int {
	offset -= sovComposition(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Composition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovComposition(uint64(m.Id))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *CompositionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeRef != nil {
		l = m.CompositeTypeRef.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovComposition(uint64(l))
		}
	}
	return n
}

func (m *CompositeTypeRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	if len(m.Patches) > 0 {
		for _, e := range m.Patches {
			l = e.Size()
			n += 1 + l + sovComposition(uint64(l))
		}
	}
	return n
}

func (m *Base) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *Patch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.FromFieldPath)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.ToFieldPath)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	if len(m.Transforms) > 0 {
		for _, e := range m.Transforms {
			l = e.Size()
			n += 1 + l + sovComposition(uint64(l))
		}
	}
	return n
}

func (m *Transformer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != nil {
		n += m.Transform.Size()
	}
	return n
}

func (m *Transformer_Map) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Map)
	n += 1 + l + sovComposition(uint64(l))
	return n
}
func (m *Transformer_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.String_ != nil {
		l = m.String_.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *Transformer_Math) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Math != nil {
		l = m.Math.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *Transformer_Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *Transformer_Convert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Convert != nil {
		l = m.Convert.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *StringTransform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransformType != nil {
		n += m.TransformType.Size()
	}
	return n
}

func (m *StringTransform_Convert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Convert != nil {
		l = m.Convert.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *StringTransform_Format) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Format != nil {
		l = m.Format.Size()
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}
func (m *StringConvert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Convert)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *StringFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fmt)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *MathTransform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *MathTransform_ClampMin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *MathTransform_ClampMax) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *MathTransform_Multiply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *MatchTransform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for _, e := range m.Patterns {
			l = e.Size()
			n += 1 + l + sovComposition(uint64(l))
		}
	}
	l = len(m.FallbackTo)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.FallbackValue)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *Pattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func (m *ConvertTransform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToType)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovComposition(uint64(l))
	}
	return n
}

func sovComposition(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComposition(x uint64) (n int) {
	return sovComposition(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Composition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Composition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Composition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CompositionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompositeTypeRef == nil {
				m.CompositeTypeRef = &CompositeTypeRef{}
			}
			if err := m.CompositeTypeRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeTypeRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTypeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTypeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &Base{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patches = append(m.Patches, &Patch{})
			if err := m.Patches[len(m.Patches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Base) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Base: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Base: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Patch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Patch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Patch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromFieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromFieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToFieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToFieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transforms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transforms = append(m.Transforms, &Transformer{})
			if err := m.Transforms[len(m.Transforms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transformer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transformer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transformer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transform = &Transformer_Map{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringTransform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Transform = &Transformer_String_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Math", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MathTransform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Transform = &Transformer_Math{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchTransform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Transform = &Transformer_Match{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConvertTransform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Transform = &Transformer_Convert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringTransform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringTransform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringTransform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringConvert{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TransformType = &StringTransform_Convert{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringFormat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TransformType = &StringTransform_Format{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringConvert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringConvert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringConvert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Convert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MathTransform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MathTransform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MathTransform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClampMin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Operation = &MathTransform_ClampMin{float64(math.Float64frombits(v))}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClampMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Operation = &MathTransform_ClampMax{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiply", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Operation = &MathTransform_Multiply{float64(math.Float64frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchTransform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchTransform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchTransform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patterns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patterns = append(m.Patterns, &Pattern{})
			if err := m.Patterns[len(m.Patterns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertTransform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertTransform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertTransform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComposition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComposition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComposition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComposition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComposition(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComposition
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComposition
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComposition
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComposition
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComposition
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComposition        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComposition          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComposition = fmt.Errorf("proto: unexpected end of group")
)
